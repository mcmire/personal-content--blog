---
title: "Building Minesweeper in JavaScript: Part 5"
teaser: "..."
date: 2020-01-01
tags: programming
vi: ft=ghmarkdown
---

[We've now got it][minesweeper-4] so that when the player clicks a mine, we
reveal all mines across the board, signaling the end of the game. But what
happens if the player clicks a space that *isn't* a mine? As we mentioned
before, there are two possible outcomes depending on the spaces that neighbor
the space itself:

* If any of the space's neighbors are a mine, we count how many there are
  and uncover the space, displaying that number inside the space.
* If none of the neighbors are mines, we uncover the space but do not display a
  number inside. Of the neighbors, we also uncover any that have no mine
  neighbors themselves, then uncover *their* neighbors that have no mine
  neighbors, and so forth and so on until we run out of spaces to uncover.

As before, let's 

Before we can decide which path to take, we'll first need to determine how many
of a space's neighbors are mines. And to do *that*, we'll need to find the
neighbors themselves.

[minesweeper-4]: /blog/minesweeper-4

### Meeting the neighbors

First things first: what do we mean by the "neighbors" of a space? We mean the
spaces that sit adjacent to it in all directions, as well as the spaces that are
directly diagonal to it in all directions. For instance, the grey spaces here
are neighbors of the red space in the middle:

<div class="image with-smaller-max-height"
  ><%= embed_svg("minesweeper-5/neighbors.svg") %></div>

Most spaces will have 9 neighbors, except for those spaces on the edge of the
board. For instance, a corner space has only 3 neighbors:

<div class="image with-smaller-max-height"
  ><%= embed_svg("minesweeper-5/neighbors-at-corner.svg") %></div>

With that in mind, how do we find them? Well, remember in [part
3][minesweeper-3] how we learned that we have a way to denote the location of a
space using X- and Y-coordinates?

[minesweeper-3]: /blog/minesweeper-3

<div class="image with-max-height"
  ><%= embed_svg("minesweeper-3/row-and-column-indices.svg") %></div>

If we had a way to look up certain spaces by their coordinates, we could take a
space's coordinates and add or subtract a row or column from them in as many
directions as were allowable. Then we'd have coordinates for that space's
neighbors and we could look up the spaces that belong to those coordinates.

Let's review the loop that we're using to draw the spaces:

``` javascript
for (let rowIndex = 0; rowIndex < 9; rowIndex++) {
  ...
  for (let columnIndex = 0; columnIndex < 9; columnIndex++) {
    const space = $("<td>");
    ...
  }
  ...
}
```

So here we have spaces -- which are really `td` elements -- and we have the
`rowIndex`es and `columnIndex`es that represents those spaces on the board. But
we don't have a way to look up arbitrary spaces. What's the simplest way to do
this?

We'll have to put on our imagination hat for a bit. What if we had an array of
arrays of `td` elements, where the outer array represented the rows in the board
and each inner array represented the column in a row?

<div class="image"><%= embed_svg("minesweeper-5/cells.svg") %></div>

Then we could drill down to a space by reusing the `rowIndex` and `columnIndex`
of that space. For instance, if this imaginary array were stored in a variable
called `spaces`, then we could use `spaces[3][5]` to refer to the `td`
highlighted in red above. And we could use `spaces[2][5]` to refer to its
northern neighbor, and `spaces[3][6]` to refer to its eastern neighbor, and so
on.

So let's turn this `spaces` array into reality. We'll modify `minesweeper.js` so
that each time we build a row, we add a new inner array to `spaces`, and each
time we build a `td`, we add it to the inner array:

``` diff
 ...
 const mines = [];
+const spaces = [];

 for (let rowIndex = 0; rowIndex < 9; rowIndex++) {
   const row = $("<tr>");
+
   board.append(row);
+  spaces[rowIndex] = [];
+
   for (let columnIndex = 0; columnIndex < 9; columnIndex++) {
     const space = $("<td>");
     const possibleMineLocation = (rowIndex * 9) + columnIndex;
     const isMine = (mineLocations.indexOf(possibleMineLocation) !== -1);

     if (isMine) {
       mines.push(space);
     }
+
+    spaces[rowIndex][columnIndex] = space;

     row.append(space);

     space.on("click", () => {
       if (isMine) {
         mines.forEach(mine => {
           mine.addClass("mine");
         });
       }
     });
   }
 }
```
{:data-no-overflow="true"}

Now we can write some code to retrieve the neighbors for a given space.
not sure where to put this code just yet, so we'll place it here for now and
move it to the right place in a moment.)

``` javascript
// for some given space with rowIndex and columnIndex:
const north = spaces[rowIndex - 1][columnIndex];
const south = spaces[rowIndex + 1][columnIndex];
const west = spaces[rowIndex][columnIndex - 1];
const east = spaces[rowIndex][columnIndex + 1];
const northwest = spaces[rowIndex - 1][columnIndex - 1];
const northeast = spaces[rowIndex - 1][columnIndex + 1];
const southwest = spaces[rowIndex + 1][columnIndex - 1];
const southeast = spaces[rowIndex + 1][columnIndex + 1];
const neighbors = [
  north,
  south,
  west,
  east,
  northwest,
  northeast,
  southwest,
  southeast
];
```

That would work for a space that's sitting in the middle of the board, but not
one that sits at the edge. So we need to check for that:

``` javascript
// for some given space with rowIndex and columnIndex:
const previousRow = spaces[rowIndex - 1];
const nextRow = spaces[rowIndex + 1];
const previousColumn = spaces[columnIndex - 1];
const nextColumn = spaces[columnIndex + 1];
const neighbors = [];

const west = spaces[rowIndex][columnIndex - 1];
const east = spaces[rowIndex][columnIndex + 1];

if (west != null) {
  neighbors.push(west);
}

if (east != null) {
  neighbors.push(east);
}

if (previousRow != null) {
  const north = previousRow[columnIndex];
  const northwest = previousRow[columnIndex - 1];
  const northeast = previousRow[columnIndex + 1];

  neighbors.push(north);

  if (northwest != null) {
    neighbors.push(northwest);
  }

  if (northeast != null) {
    neighbors.push(northeast);
  }
}

if (nextRow != null) {
  const south = nextRow[columnIndex];
  const southwest = nextRow[columnIndex - 1];
  const southeast = nextRow[columnIndex + 1];

  neighbors.push(south);

  if (southwest != null) {
    neighbors.push(southwest);
  }

  if (southeast != null) {
    neighbors.push(southeast);
  }
}
```

That's quite a lot of code just to look for the neighbors. Is there some way
that we can reduce it? 

### Counting neighboring mines

In order to count mines around a particular space, we need to gather that
space's neighbors.
